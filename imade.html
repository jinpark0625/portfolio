<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>Document</title>

    <style>
      @font-face {
        font-family: "Noto-Sans KR";
        src: url("public/font/NotoSansKR-Medium.otf") format(opentype);
        font-weight: normal;
        font-style: normal;
      }
      @font-face {
        font-family: "ChosunSm";
        src: url("https://cdn.jsdelivr.net/gh/projectnoonnu/noonfonts_20-04@1.1/ChosunSm.woff")
          format("woff");
        font-weight: normal;
        font-style: normal;
      }
      @font-face {
        font-family: "ChosunKm";
        src: url("public/font/ChosunKm.ttf") format(truetype);
        font-weight: normal;
        font-style: normal;
      }

      body {
        margin: 0;
        padding: 0;
        display: flex;
        justify-content: center;
        align-items: center;
      }
      canvas {
        background-color: #080808;
      }
      .noise {
        z-index: 2;
      }
      .noise:after {
        content: "";
        position: absolute;
        z-index: -1;
        top: 0;
        bottom: 0;
        left: 0;
        right: 0;
        background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAyCAYAAAAeP4ixAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAABIFJREFUeNrEWk1rGzEQXWuX0prQECcQYjAUFvbqs3NMfnz+QyDXQiBpaA+hPRhXMpIrT97MPKXQGhRJu/pYab7ezCR0XTfFMu52u67Uso2eyffyXS7zUpy1Fi37yu9NdYh/tqk1m83GUst26aP3pY4LPtTjUj/Xr6nIder58f232F7I57Itf2WP0ums27AooFBBXUPeYtVe5DIiqmscc7QGsQk8gEdu60OsD9P6HqsNFukACzxIFkLklqxRsdmDfK6tZY0F8/qOEeh86ncpBUtANXZkuaD+tllulN9LOnA+9YsmbPJ20Lj6eRmPFAKaV1MRUVb292uIU5/l9hkrtJ5MaVRA81hKozlB3MaLvBlNBSP50W5ZzOkR5czbBnIi5WWQgxHroPdoPCnMW+WA1iVM8d09EvoyZtD42vpAjRKIly3+1+aAfbcOlf/Ykc1ms8x8t9JkwtIyjC1h+b5x3aRNp4OM3N3dfapPe3t7e2ppLUQVC+oUG6TxvaatCHu13Rfl5CtPk7BwhrEpFvRpmMcZtKp9zn50CxtphxDrn5UC5vE3lNvn5UCsTHgHYICrZ+c6dtP4+5zrj7Gc5vbSA4kWSs7lKj+/sgQbUOboICHpaM0wKbr+Zyzfc/sro16lahXteV5/7sGd5+fnkN8tkCmgoHuhSqFMTRHvFhlgKN5N3lpyz8GD4B5I1CwtMnCmQTMQBeIUqfIHyxojy2v5Ih4CljbFWLeGMX0NTxT27wNaqPU25AfWxk+TO+25IqOTBuVLO8gbQrcshUpujCy2FzBg9spj95a7nodYubNwFfLEEiZjBbcea6lgw8eZNNUux82KeWc8MVYONLnQ5mqs7cjRkQgEJn6E5ODm5uY1CZkXB5P2RMqPxqZWfAvKLAshvBAQG/ph3NtGZHAc1/JCoP8RKI7MmJDJNrf8AOm/a2TXQqKIHbwoDFLp6dn19fVS04QjCjJ70T4POnhxMgcKja1RSai1LPCoxagYO+FpJU97WXZpYDZiLHyttTQoAVhvqrMB1fheBhyYgB9kh6enpwC1A6kEPEPGuMG1QfTYc5YbEN16lPHCqchHsVC0pyjMb9mfxrCYbDxX28zSVkZ0XVr9y9h/THXsniAEERi44IHKFtVqwXkUuMv9x7rWZG782+wU4m3P8jNF7HlpqfmAgtUSMkuojqC7YIt7Vp03tE+kRnwTMm1JtVlazDNujS7D2OIyBAbtahESLdvLQBwme5vCuEg20b4H9fuv/AZrfS0LYM19k0Ns/WcBFp6zGeDGtPgkFUpgsrmpXq/XvzS1ivIbKPiA1KyFnFFkv4qybOu1BtZlVUlahW8AS6zys1XsfrCsuZX08VLXB1dXE1SN56ubvc+qtrdQQXSLf2hC68mBlsc0XV0mD86ESKdpWuX+qhTWO2RVOtjf99M9J6fV1fWUxXuSSoFJcWkyY+EsLTuLWNBLuKJnUs6CyBteXVxcfDHy2n0JASH5QTZF8PwWpRs8h83735RDEFsTbMZAeinp6gK6ojKJ8Z2kuob5yrzfAgwASaYfY2UgQSYAAAAASUVORK5CYII=);
        -ms-filter: "progid:DXImageTransform.Microsoft.Alpha(Opacity=60)";
        filter: alpha(opacity=60);
        opacity: 0.6;
      }
      .text {
        font-size: 1.4rem;
        font-family: "ChosunSm";
        color: #d4d4d4;
        position: absolute;
        left: 50%;
        top: 23%;
        transform: translate(-50%, 0%);
        opacity: 0;
        transition: opacity 0.6s ease-in-out;
      }
      .next {
        display: flex;
        justify-content: center;
        align-items: center;
        width: 90px;
        height: 90px;
        font-size: 1rem;
        font-family: "ChosunSm";
        color: #d4d4d4;
        position: absolute;
        left: 50%;
        top: 70%;
        transform: translate(-50%, 0%);
        opacity: 0;
        transition: opacity 0.6s ease-in-out;
        cursor: pointer;
        z-index: 2;
      }
      .next:hover .border {
        transform: scale(1.1);
      }
      .border {
        position: absolute;
        width: 100%;
        height: 100%;
        border-radius: 100%;
        border: 1px solid rgba(212, 212, 212, 0.4);
        box-shadow: 0px 0px 4px 0px #d4d4d4;
        transition: transform 0.6s ease-in-out;
        transform-origin: 30% 50%;
      }
      .show {
        opacity: 1;
      }
    </style>
  </head>
  <body>
    <canvas></canvas>
    <div class="noise"></div>
    <h4 class="text">점들을 이어주세요.</h4>
    <span class="next"
      ><h4>다음으로</h4>
      <div class="border"></div
    ></span>

    <script>
      window.addEventListener("load", () => {
        const text = document.querySelector(".text");
        text.classList.add("show");
      });

      // globals
      const DOT_COUNT = 8;
      const MIN_DOT_SIZE = 5;
      const DOT_SIZE_RANGE = 25;
      const MAX_VELOCITY = 2;
      const MOUSE_DISTANCE = 50;
      const BORDER_GROW_SPEED = 1;
      let linkDot = null;

      //   set up canvas
      const canvas = document.querySelector("canvas");
      canvas.width = innerWidth;
      canvas.height = innerHeight;
      const c = canvas.getContext("2d");

      window.addEventListener("resize", (e) => {
        canvas.width = innerWidth;
        canvas.height = innerHeight;
        init();
      });

      //   set up start
      let dotArray = [];
      let linksArray = [];

      // track mouse
      let mouse = {
        x: undefined,
        y: undefined,
      };

      window.addEventListener("mousemove", (e) => {
        mouse.x = e.x;
        mouse.y = e.y;
      });

      //    track click
      let click = {
        x: undefined,
        y: undefined,
      };

      window.addEventListener("mousedown", (e) => {
        click.x = e.x;
        click.y = e.y;
      });

      function init() {
        dotArray = [];
        linksArray = [];

        for (let i = 0; i < DOT_COUNT; i++) {
          // set up dot radius
          let radius = Math.random() * DOT_SIZE_RANGE + MIN_DOT_SIZE;
          let x = Math.random() * (innerWidth - radius * 2) + radius;
          let y = Math.random() * (innerHeight - radius * 2) + radius;
          let dx = (Math.random() - 0.5) * MAX_VELOCITY;
          let dy = (Math.random() - 0.5) * MAX_VELOCITY;

          let border = new Border(x, y, radius);
          dotArray.push(new Dot(radius, x, y, dx, dy, border));
        }
        animate();
      }

      // Border class
      class Border {
        constructor(x, y, radius) {
          this.x = x;
          this.y = y;
          this.radius = radius;
          //for resizing
          this.initialRadius = radius;
          this.radiusTarget = radius + radius / 2;
          this.counted = false;
        }

        draw = () => {
          c.beginPath();
          c.lineWidth = 1;
          c.shadowBlur = 10;
          // 0pi ~ 2pi (startAngle)
          c.arc(this.x, this.y, this.radius, Math.PI * 2, false);
          c.strokeStyle = "#D4D4D4";
          c.stroke();
        };

        update = (newX, newY) => {
          this.x = newX;
          this.y = newY;
          this.draw();
        };

        expand = () => {
          this.radius += BORDER_GROW_SPEED;
        };

        shrink = () => {
          this.radius -= BORDER_GROW_SPEED;
        };
      }

      //   Dot class
      class Dot {
        constructor(radius, x, y, dx, dy, border) {
          this.x = x;
          this.y = y;
          this.dx = dx;
          this.dy = dy;
          this.radius = radius;
          this.minRadius = radius;
          this.border = border;
          this.color = "#D4D4D4";

          this.border.draw();
        }
        draw = () => {
          c.beginPath();
          c.arc(this.x, this.y, this.radius, Math.PI * 2, false);
          c.fillStyle = this.color;
          c.shadowColor = this.color;
          c.shadowBlur = 10;
          c.fill();
        };
        update() {
          if (this.x + this.radius >= innerWidth || this.x - this.radius <= 0) {
            // to make the dots bounce off wall
            this.dx = -this.dx;
          }

          if (
            this.y + this.radius >= innerHeight ||
            this.y - this.radius <= 0
          ) {
            // to make the dots bounce off wall
            this.dy = -this.dy;
          }

          //move the dots
          this.x += this.dx;
          this.y += this.dy;

          //mouse interactivity

          if (
            mouse.x - this.x < MOUSE_DISTANCE &&
            mouse.x - this.x > -MOUSE_DISTANCE &&
            mouse.y - this.y < MOUSE_DISTANCE &&
            mouse.y - this.y > -MOUSE_DISTANCE &&
            this.border.radius < this.border.radiusTarget
          ) {
            this.border.expand();
          } else if (this.border.radius > this.border.initialRadius) {
            this.border.shrink();
          }

          //mouse click
          if (
            click.x < this.x + this.radius &&
            click.x > this.x - this.radius &&
            click.y < this.y + this.radius &&
            click.y > this.y - this.radius
          ) {
            if (linkDot) {
              createLink(this);
            } else {
              linkDot = this;
            }
            click.x = undefined;
            click.y = undefined;
          }
          this.draw();
          this.border.update(this.x, this.y);
        }
      }

      function renderActiveLink() {
        c.beginPath();
        c.lineWidth = 5;
        c.shadowBlur = 0;
        c.moveTo(linkDot.x, linkDot.y);
        c.lineTo(mouse.x, mouse.y);
        c.strokeStyle = "#D4D4D4";
        c.stroke();
      }

      function createLink(target) {
        linksArray.push(new Link(linkDot, target));
        linkDot = null;
      }

      class Link {
        constructor(start, end) {
          this.start = start;
          this.end = end;

          countEnd(this.end);
        }
        draw() {
          c.beginPath();
          c.lineWidth = 5;
          c.shadowBlur = 10;
          c.moveTo(this.start.x, this.start.y);
          c.lineTo(this.end.x, this.end.y);
          c.strokeStyle = "#D4D4D4";
          c.stroke();
        }
      }

      let num = 0;
      function countEnd(end) {
        if (end) {
          num++;
          if (num >= 3) {
            showText();
          }
        }
      }

      function showText() {
        const next = document.querySelector(".next");
        next.classList.add("show");
      }

      function animate() {
        requestAnimationFrame(animate);
        // to make the dots look like circles
        c.clearRect(0, 0, innerWidth, innerHeight);

        for (let i = 0; i < dotArray.length; i++) {
          dotArray[i].update();
        }

        for (let i = 0; i < linksArray.length; i++) {
          linksArray[i].draw();
        }
        if (linkDot) {
          renderActiveLink();
        }
      }
      init();
    </script>
  </body>
</html>
